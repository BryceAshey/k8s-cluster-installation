#!/usr/bin/env bash

set -eo pipefail

[[ -n $DEBUG ]] && set -x

USER_NAME=kube-admin-user
CLUSTER_NAME=kubernetes

usage(){
    echo "Usage:"
    echo "  gen [command]"
    echo "    all           (a)     Approve a Kubernetes certificate signing request"
    echo "    create        (c)     Create a Kubernetes certificate signing request and apply manifest"
    echo "    approve       (p)     Approve a Kubernetes certificate signing request"
    echo "    kubeconfig    (k)     Generates the kubeconfig - requires existing CSR has been approved and exists in the cluster"
    echo "    show          (s)     Print the kubeconfig to STDOUT"
    echo "    delete        (d)     Delete all locally generated files. This does not include resources created in the cluster"
    echo ""
    echo "  Configurable env vars:"
    echo "    \$CLUSTER_NAME    Sets cluster name to use, this should match what is in your kubeconfig. Default: 'kubernetes'. (optional)"
    echo "    \$USER_NAME       Sets the user name to use for RBAC, this will be the user provided with auth access. Default: 'cluster-admin-user'. (optional)"
    echo "    \$INSECURE        Enable TLS insecure-skip-tls-verify. Default: false (optional)"
    echo "    \$DEBUG           Sets logging to verbose. (optional)"
}

if ! [ -x "$(command -v openssl)" ]; then
    echo 'Error: openssl is not installed.' >&2
    exit 1
fi

if ! [ -x "$(command -v kubectl)" ]; then
    echo 'Error: kubectl is not installed.' >&2
    exit 1
fi

all() {
    create
    approve
    config
    generate_kubeconfig
    set_rbac_permissions
}

config() {
    # After CSR is approved it takes a few seconds to update the resources
    sleep 2
    kubectl get csr access-request -o jsonpath='{.status.certificate}' | base64 --decode > client.pem
    kubectl config view -o=jsonpath="{.clusters[?(@.name=='${CLUSTER_NAME}')].cluster.certificate-authority-data}" --raw | base64 --decode - > ca.pem
}

create() {
    echo "Checking if key already exists..."
    sed "s/\$CN/${USER_NAME}/g" template.conf > csr.conf
    echo "Generating certificate signing request and key with OpenSSL..."
    openssl req -new -config csr.conf -keyout key.pem -out "${USER_NAME}.csr"
    CSR_OUTPUT=$(< "${USER_NAME}.csr" base64 | tr -d '\n')
    sed "s/\$CSR/${CSR_OUTPUT}/g" template.yaml > csr.yaml
    echo "Generated kubernetes certificate signing request manifest..."
    kubectl apply -f csr.yaml
}

approve() {
    echo "Approving certificate signing request"
    kubectl certificate approve access-request
}

create_kubeconfig() {
    config
    generate_kubeconfig
}

generate_kubeconfig() {
    # TODO: Resolve DNS without cert signed issue.
    # kubectl config set-cluster "$(kubectl config view -o jsonpath='{.clusters[0].name}')" \
    #     --server="https://api-server.raspbernetes.com" \
    #     --insecure-skip-tls-verify \
    #     --kubeconfig=kube-config
    kubectl config set-cluster "$(kubectl config view -o jsonpath='{.clusters[0].name}')" \
        --server="$(kubectl config view -o jsonpath='{.clusters[0].cluster.server}')" \
        --certificate-authority=ca.pem \
        --kubeconfig=kube-config \
        --embed-certs
    kubectl config set-credentials "${USER_NAME}" \
        --client-certificate=client.pem \
        --client-key=key.pem \
        --kubeconfig=kube-config \
        --embed-certs
    kubectl config set-context "${USER_NAME}@${CLUSTER_NAME}" \
        --cluster="$(kubectl config view -o jsonpath='{.clusters[0].name}')" \
        --user="${USER_NAME}" \
        --namespace=default \
        --kubeconfig=kube-config
    kubectl config use-context "${USER_NAME}@${CLUSTER_NAME}" \
        --kubeconfig=kube-config
}

print_kubeconfig() {
    if [[ ! -f kube-config ]]; then
        echo "kubeconfig hasn't been created"
        exit 1
    fi
    cat kube-config
    echo ""
    echo "To use the generated kubeconfig simple pass \"--kubeconfig=kube-config\" into the kubectl command"
    echo "Examples:"
    echo -e "\tkubectl get pods --kubeconfig=kube-config"
    echo -e "\tkubectl get nodes --kubeconfig=kube-config"
}

set_rbac_permissions() {
    echo "Setting admin permissions for user: ${USER_NAME}"
    kubectl create clusterrolebinding ${USER_NAME} --namespace=default --clusterrole=cluster-admin --user=${USER_NAME}
}

delete() {
    echo "Delete all locally generated files..."
    rm -f "${USER_NAME}.csr" key.pem csr.yaml ca.pem kube-config client.pem csr.conf
    echo "Delete Kubernetes resources"
    kubectl delete csr access-request
    kubectl delete clusterrolebinding "${USER_NAME}"
}

case "${1:-}" in
    all|a)
        all
        ;;
    create|c)
        create
        ;;
    approve|p)
        approve
        ;;
    kubeconfig|k)
        create_kubeconfig
        ;;
    show|s)
        print_kubeconfig
        ;;
    rbac|r)
        set_rbac_permissions
        ;;
    delete|d)
        delete
        ;;
    *)
        usage >&2
        exit 1
        ;;
esac